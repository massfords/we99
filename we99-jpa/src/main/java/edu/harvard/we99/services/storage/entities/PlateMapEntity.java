package edu.harvard.we99.services.storage.entities;

import edu.harvard.we99.domain.Coordinate;

import javax.annotation.Generated;
import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;
import javax.validation.constraints.Size;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * @author mford
 */
@Entity
@Table(name = "platemaps")
public class PlateMapEntity extends AbstractPlateEntity<PlateMapEntity> {
    /**
     * A plate consists of Wells in which the compounds we want to test are placed.
     * Each well is uniquely identified by a row,col coordinate within this plate
     * so we'll store them according to their coordinate.
     */
    @OneToMany(orphanRemoval = true, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @Size(min = 0)
    @MapKey(name="coordinate")
    private Map<Coordinate, WellMapEntity> wells = new LinkedHashMap<>();


    @PrePersist
    @PreUpdate
    private void validate() {
        checkWells(wells.keySet());
    }

    @Generated(value = "generated by IDE")
    public Map<Coordinate, WellMapEntity> getWells() {
        return wells;
    }

    @Generated(value = "generated by IDE")
    public void setWells(Map<Coordinate, WellMapEntity> wellMaps) {
        this.wells = wellMaps;
    }

    public PlateMapEntity withWells(WellMapEntity... wellMapEntities) {
        for(WellMapEntity wme : wellMapEntities) {
            wells.put(wme.getCoordinate(), wme);
        }
        return this;
    }

    public void add(WellMapEntity wellMapEntity) {
        wells.put(wellMapEntity.getCoordinate(), wellMapEntity);
    }
}
