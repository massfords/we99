package edu.harvard.we99.security;

import javax.annotation.Generated;
import javax.persistence.Embeddable;
import javax.validation.constraints.NotNull;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

/**
 * Models the name of a permissions. Not much more than a wrapper around a
 * String but at least this makes the service calls that deal with Role Names
 * able to take something other than a String in their signature.
 *
 * @author mford
 */
@Embeddable
@XmlAccessorType(XmlAccessType.FIELD)
@XmlJavaTypeAdapter(RoleNameAdapter.class)
public class RoleName {

    /**
     * These are the well known system roles. If we need to support user defined
     * roles, then we'll put them somewhere else.
     */
    public enum BuiltIn {
        Admin, Scientist, Guest;

        public RoleName asName() {
            return new RoleName(name());
        }
    }

    @NotNull
    private String name;

    public RoleName() {}

    public RoleName(String name) {
        this.name = name;
    }

    @Generated(value = "generated by IDE")
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return getName();
    }

    @Generated(value = "generated by IDE")
    public void setName(String name) {
        this.name = name;
    }

    @Override
    @Generated(value = "generated by IDE")
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        RoleName roleName = (RoleName) o;

        if (!name.equals(roleName.name)) return false;

        return true;
    }

    @Override
    @Generated(value = "generated by IDE")
    public int hashCode() {
        return name.hashCode();
    }
}
